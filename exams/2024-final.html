<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Your Name">
<meta name="dcterms.date" content="2024-05-08">

<title>Stat 151 Final Exam – Stat 151</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Stat 151</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://srvanderplas.github.io/stat-computing-r-python/"> 
<span class="menu-text">Textbook</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.pdf"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#instructions" id="toc-instructions" class="nav-link active" data-scroll-target="#instructions">Instructions</a>
  <ul class="collapse">
  <li><a href="#rules" id="toc-rules" class="nav-link" data-scroll-target="#rules">Rules</a></li>
  </ul></li>
  <li><a href="#wordle" id="toc-wordle" class="nav-link" data-scroll-target="#wordle">Wordle!</a>
  <ul class="collapse">
  <li><a href="#part-1-read-in-and-clean-the-data" id="toc-part-1-read-in-and-clean-the-data" class="nav-link" data-scroll-target="#part-1-read-in-and-clean-the-data">Part 1: Read in and Clean the Data</a></li>
  <li><a href="#part-2-functions" id="toc-part-2-functions" class="nav-link" data-scroll-target="#part-2-functions">Part 2: Functions</a></li>
  <li><a href="#part-3-assessing-word-frequency" id="toc-part-3-assessing-word-frequency" class="nav-link" data-scroll-target="#part-3-assessing-word-frequency">Part 3: Assessing Word Frequency</a></li>
  <li><a href="#part-4-decoding-wordle-bot" id="toc-part-4-decoding-wordle-bot" class="nav-link" data-scroll-target="#part-4-decoding-wordle-bot">Part 4: Decoding Wordle-Bot</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Stat 151 Final Exam</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Week15</div>
    <div class="quarto-category">Exam</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Your Name </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2024-05-08</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="instructions" class="level1">
<h1>Instructions</h1>
<ul>
<li><p>This exam is due at 6pm on May 10, 2024. Your exam MUST BE PUSHED TO GITHUB CLASSROOM by 6pm. Please double-check your github repository to ensure that the file that is on github is the file you want me to grade.</p></li>
<li><p>For each of these problems, you may choose to solve the problem in either R or python.<br>
The chunks I’ve provided are R chunks, but you are free to change the code type to python; I just want to ensure that your answers are where I expect them to be.</p></li>
</ul>
<section id="rules" class="level2">
<h2 class="anchored" data-anchor-id="rules">Rules</h2>
<ul>
<li><p>You may use the textbook, your notes, and google on this exam, but you may not post this exam and ask for help on any site.<br>
It is ok to google, for instance, how to convert a string to a list of characters, but it is not ok to google how to solve the entire question. Please ask if you are concerned about any possible edge cases.</p></li>
<li><p>You may NOT confer with other people or AI entities - including posting on StackOverflow, Reddit, etc. Pre-existing posts on SO are fair game, though.</p></li>
<li><p>You must be able to explain how any code you submit on this exam works. Oral exams based on your submissions will be held M-W May 13-15 (e.g.&nbsp;during finals week)</p></li>
<li><p>You may ask clarifying questions of Dr.&nbsp;Vanderplas or Muxin Hua by email/zoom or in person</p></li>
<li><p>There are a total of 70 points available on this exam.</p></li>
<li><p>If you get stuck, you may email Dr.&nbsp;Vanderplas for the solution to the problem you are stuck on, at the cost of the points which would be awarded for that problem. Please specify the part and question number, if you decide to use this option. This is designed to get you un-stuck and allow you to complete problems</p></li>
<li><p>(6 points) Your submitted qmd file must compile without errors .<br>
Use <code>error=TRUE</code> in a chunk if it is supposed to return an error (for instance, if you are demonstrating error handling).</p></li>
</ul>
</section>
</section>
<section id="wordle" class="level1">
<h1>Wordle!</h1>
<p>Wordle is a web-based word game created by Josh Wardle and currently owned by the New York Times. Players get 6 attempts to guess a five-letter word. On each attempt, letters that are in the solution but not in the correct place are indicated with yellow tiles, and letters that are in the correct place are indicated with green tiles.</p>
<p>You can play wordle <a href="https://www.nytimes.com/games/wordle/index.html">here</a>.</p>
<p>In this assignment, you will work with two data sets:</p>
<ul>
<li><p>wordle-words.csv, which contains the valid guesses, answers for all 2315 days of predetermined wordle solutions in the original version of the game, and google N-gram word frequency of each word between 1970 and 2019. This data was modified from the csv provided by https://github.com/steve-kasica/wordle-words/.</p></li>
<li><p>guess-words.csv, which contains an additional 1881 valid guesses which were added when the New York Times took over the game in January of 2022. These words were obtained from <a href="https://gist.github.com/nshafer/8e12aa557cc91c6b16a6057e83e4741e">this list</a> and I used <a href="fetch.py">fetch.py</a> to obtain the N-gram word frequency for these words.</p></li>
</ul>
<p>Because of changes in the NYT version of wordle, 7 of the original 2315 solutions have been removed from the game. In order to additionally safeguard against any spoilers for wordle players, I have shuffled the solution days in this data set so that all actual solutions are still marked as such, but the days reported in this data set are not the actual days on which the words will appear. I used the file <a href="shuffle-answers.R">shuffle-answers.R</a> to perform this operation (you don’t need to use this file, but I like to be transparent).</p>
<section id="part-1-read-in-and-clean-the-data" class="level2">
<h2 class="anchored" data-anchor-id="part-1-read-in-and-clean-the-data">Part 1: Read in and Clean the Data</h2>
<p>(6 points total)</p>
<ol type="1">
<li>(2 points) Read in the file <code>wordle-words.csv</code> and store the data in a variable named <code>orig</code>. Read in the file <code>guess-words.csv</code> and store the data in a variable named <code>guess</code>.</li>
</ol>
<ol start="2" type="1">
<li>(4 points) Is the <code>orig</code> data in tidy form? Explain - if it is, list the features of tidy data and how this data set meets the requirements. If not, list the features of tidy data this data set violates, and explain what a tidy form of the data would look like.</li>
</ol>
</section>
<section id="part-2-functions" class="level2">
<h2 class="anchored" data-anchor-id="part-2-functions">Part 2: Functions</h2>
<p>(24 points total)</p>
<p>In this part of the exam, use only the <code>orig</code> words.</p>
<p>You may need to write a for loop to check whether each letter is (or is not) in the vector of words. If you start with a vector that has 0 for each word in the list, you can use addition operations to ensure that only words with all of the provided letters are returned.</p>
<p>In R, the <code>letters</code> object contains all 26 valid lowercase latin letters.</p>
<ol type="1">
<li>(4 points) Write a function named <code>filter_yellow(words, x)</code> that uses the words data and a vector of lowercase letters, <code>x</code>, which are in the wordle solution and returns all possible words containing those letters.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter_yellow</span>(orig, <span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"e"</span>, <span class="st">"i"</span>, <span class="st">"u"</span>)) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Error in filter_yellow(orig, c("a", "e", "i", "u")): could not find function "filter_yellow"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#        word   occurrence day</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 110   adieu 2.186597e-06  NA</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 653   aurei 7.694299e-08  NA</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 11968 uraei 1.093829e-08  NA</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">filter_yellow</span>(orig, <span class="fu">c</span>(<span class="st">"q"</span>, <span class="st">"u"</span>, <span class="st">"e"</span>, <span class="st">"y"</span>)) </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="do">## Error in filter_yellow(orig, c("q", "u", "e", "y")): could not find function "filter_yellow"</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#       word   occurrence  day</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 8779 query 8.135131e-06 1495</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 8782 queyn 5.189541e-10   NA</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 8783 queys 3.685211e-10   NA</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 8818 quyte 5.250099e-09   NA</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="2" type="1">
<li><p>(2 points) Modify <code>filter_yellow(words, x)</code> so that the function will return a useful error if the <code>words</code> data frame does not have a column named <code>word</code>.</p></li>
<li><p>(2 points) Modify <code>filter_yellow(words, x)</code> so that the function will return a warning if any characters provided are not letters (A-z), and then will drop the non-letter characters from the vector before returning results using the valid letters.</p></li>
<li><p>(2 points) Modify <code>filter_yellow(words, x)</code> so that the function can accept uppercase or lowercase letters, but will convert the letters to lowercase automatically without an error.</p></li>
<li><p>(4 points) Write a function named <code>filter_black(y)</code> that takes a vector of letters, <code>y</code>, which aren’t in the wordle solution and returns all possible words which do not contain any of those letters. Use the same error handling code that you added in parts 2-4.</p></li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter_black</span>(orig, letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">19</span>])</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Error in filter_black(orig, letters[1:19]): could not find function "filter_black"</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "tutty" "vutty"</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">filter_black</span>(orig, <span class="fu">c</span>(<span class="st">"S"</span>, <span class="st">"T"</span>, <span class="st">"C"</span>, <span class="st">"H"</span>, <span class="st">"Y"</span>, <span class="st">"R"</span>, <span class="st">"P"</span>, <span class="st">"L"</span>, <span class="st">"K"</span>, <span class="st">"G"</span>, <span class="st">"N"</span>, <span class="st">"M"</span>, <span class="st">"D"</span>, <span class="st">"F"</span>, <span class="st">"B"</span>, <span class="st">"W"</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="do">## Error in filter_black(orig, c("S", "T", "C", "H", "Y", "R", "P", "L", : could not find function "filter_black"</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "ajiva" "aquae" "avize" "jaxie" "jeeze" "juvie" "ouija"</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># [8] "ozzie" "qajaq" "queue" "zoaea" "zoeae" "zooea"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="6" type="1">
<li>(4 points) Write a function named <code>filter green(words, letters)</code> that takes a string of 5 letters (with unknowns indicated by _) and returns all words which have the specified letters in the specified position. Add error handling that identifies not-valid characters and flags strings that are not of length 5.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter_green</span>(orig, <span class="at">z =</span> <span class="st">"EXA__"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Error in filter_green(orig, z = "EXA__"): could not find function "filter_green"</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#    word   occurrence day</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 1 exact 2.450183e-05 139</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 2 exalt 5.109440e-07 449</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 3 exams 2.825810e-06  NA</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="fu">filter_green</span>(orig, <span class="at">z =</span> <span class="st">"summer"</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="do">## Error in filter_green(orig, z = "summer"): could not find function "filter_green"</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Error in filter_green(orig, z = "summer") : nchar(z) == 5 is not TRUE</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="7" type="1">
<li>(4 points) Use your functions to determine what the remaining valid words are in the following situation. Based on the word occurrence frequency, which would you guess first?<br>
Hint: You should be able to chain your functions together with pipes if you’ve set things up as instructed.</li>
</ol>
<p><img src="wordle_game.png" class="img-fluid"></p>
<ol start="8" type="1">
<li>(2 points) How would you improve your functions to make your wordle game better?</li>
</ol>
</section>
<section id="part-3-assessing-word-frequency" class="level2">
<h2 class="anchored" data-anchor-id="part-3-assessing-word-frequency">Part 3: Assessing Word Frequency</h2>
<p>(12 points total)</p>
<ol type="1">
<li>(2 points) Join the two data frames of valid wordle words to create a data frame named <code>all_words</code> of all valid words.</li>
</ol>
<ol start="2" type="1">
<li>(2 points) Create a new column in your data frame, <code>solution</code>, that is TRUE for words which are solutions to wordle puzzles, and FALSE for words which are not solutions but are valid guesses.</li>
</ol>
<ol start="3" type="1">
<li>(4 points) Using <code>ggplot2</code> or <code>plotnine</code>, create side-by-side boxplots which show the frequency of words by <code>solution</code>. You may want to use a transformation (e.g.&nbsp;<code>scale_y_log10()</code>)to make these values easier to visualize.<br>
If you cannot figure this part out, email Dr.&nbsp;Vanderplas for code at the cost of a deduction of the 4 points you would get for this question.</li>
</ol>
<ol start="4" type="1">
<li>(2 points) Make sure your plot has a title and descriptive axis labels.</li>
</ol>
<ol start="5" type="1">
<li>(2 points) Write at least 2 sentences interpreting the chart you created in part 3.</li>
</ol>
</section>
<section id="part-4-decoding-wordle-bot" class="level2">
<h2 class="anchored" data-anchor-id="part-4-decoding-wordle-bot">Part 4: Decoding Wordle-Bot</h2>
<p>(22 points total)</p>
<p>The New York Times added Wordle-Bot, which helps analyze your wordle guesses and critique your approach, when it acquired the game from its original creator.</p>
<p>This portion of the exam will help you create some of the data you would need to build your own wordle-bot clone.</p>
<ol type="1">
<li>(2 points) Starting with <code>all_words</code>, the data frame you created for Part 3, create a data frame named <code>answers</code> that contains only words which are wordle solutions.</li>
</ol>
<ol start="2" type="1">
<li>(4 points) Split the letters of the words in the <code>answers</code> data frame into separate columns, so that there is a column for all of the first letters, all of the 2nd letters, and so on. You may find it helpful to first mutate a new column and then use a function such as <code>unnest_wider()</code> to get the data into a form that you can work with. A few lines of the desired data structure is provided below.<br>
If you cannot figure this part out, email Dr.&nbsp;Vanderplas for code at the cost of a deduction of the 4 points you would get for this question.</li>
</ol>
<pre><code># A tibble: 2,315 × 9
   word    occurrence   day X1    X2    X3    X4    X5    solution
   &lt;chr&gt;        &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;   
 1 aback 0.00000113    1628 a     b     a     c     k     TRUE    
 2 abase 0.0000000618   459 a     b     a     s     e     TRUE    
 3 abate 0.00000104    1781 a     b     a     t     e     TRUE    
 4 abbey 0.00000143     841 a     b     b     e     y     TRUE    </code></pre>
<ol start="3" type="1">
<li><p>(4 points) Describe the form of the data you would need in order to compare the relative frequency of each letter in the alphabet by word position (e.g.&nbsp;1st letter, 2nd letter, 3rd letter…). Feel free to upload and include a sketch using markdown syntax, if it is easier to sketch out the form of the data you would need.</p></li>
<li><p>(4 points) Write code that will take you from the form of the data you got in question 2 to the structure you described in question 3.</p></li>
</ol>
<ol start="5" type="1">
<li>(2 points) Create a new variable named <code>letter_type</code> that has values <code>vowel</code> and <code>consonant</code>. For the purposes of this question, ‘y’ should be treated as a vowel.</li>
</ol>
<ol start="6" type="1">
<li>(4 points) Create a bar chart with letter on the x-axis and frequency on the y-axis. Facet by position so that your chart has 5 rows and a single column. The bars should be shaded according to <code>letter_type</code>, and your plot should have informative axis labels and a useful title.</li>
</ol>
<ol start="7" type="1">
<li>(2 points) How would you improve this chart so that viewers could more clearly see which letters correspond to each position? Justify your answer, using some of the information on chart perception we discussed in this class.</li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>